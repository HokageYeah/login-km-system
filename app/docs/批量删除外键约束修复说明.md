# 批量删除外键约束修复说明

## 问题描述

在执行批量删除用户操作时，遇到以下错误：

```
(mysql.connector.errors.IntegrityError) 1048 (23000): Column 'user_id' cannot be null
[SQL: UPDATE user_tokens SET user_id=%(user_id)s WHERE user_tokens.id = %(user_tokens_id)s]
```

### 错误原因

数据库表之间存在外键约束，当使用 SQLAlchemy 的 `delete()` 方法删除父记录时，ORM 会尝试将子表中的外键字段设置为 NULL。但是在我们的数据库设计中，这些外键字段都设置了 `nullable=False`，不允许为空，因此导致了完整性约束错误。

### 涉及的表关系

1. **用户删除**
   - `users` → `user_tokens` (user_id 外键，不可为空)
   - `users` → `user_cards` (user_id 外键)

2. **应用删除**
   - `apps` → `user_tokens` (app_id 外键，不可为空)
   - `apps` → `cards` (app_id 外键，不可为空)
   - `cards` → `user_cards` (card_id 外键)
   - `cards` → `card_devices` (card_id 外键)

3. **卡密删除**
   - `cards` → `user_cards` (card_id 外键)
   - `cards` → `card_devices` (card_id 外键)

---

## 解决方案

### 核心思路

在删除父记录之前，先手动删除所有子记录，避免触发外键约束。删除顺序遵循"从叶子到根"的原则。

### 修复详情

#### 1. 用户删除修复 (`app/services/auth_service.py`)

**修复前**：
```python
# 直接删除用户，依赖数据库级联
self.db.delete(user)
self.db.commit()
```

**修复后**：
```python
# 先删除用户的所有 Token（避免外键约束问题）
self.db.query(UserToken).filter(UserToken.user_id == user_id).delete()

# 删除用户的所有卡密绑定
self.db.query(UserCard).filter(UserCard.user_id == user_id).delete()

# 最后删除用户
self.db.delete(user)
self.db.commit()
```

**删除顺序**：
1. 删除 `user_tokens` 表中的记录
2. 删除 `user_cards` 表中的记录
3. 删除 `users` 表中的记录

---

#### 2. 应用删除修复 (`app/services/app_service.py`)

**修复前**：
```python
# 直接删除应用，依赖数据库级联
self.db.delete(app)
self.db.commit()
```

**修复后**：
```python
# 先删除该应用下的所有 Token（避免外键约束问题）
from app.models.user_token import UserToken
self.db.query(UserToken).filter(UserToken.app_id == app_id).delete()

# 删除该应用下的所有卡密（会级联删除卡密的绑定关系）
from app.models.card import Card
from app.models.user_card import UserCard
from app.models.card_device import CardDevice

# 获取该应用下的所有卡密ID
card_ids = [card.id for card in self.db.query(Card).filter(Card.app_id == app_id).all()]

# 删除卡密的设备绑定
if card_ids:
    self.db.query(CardDevice).filter(CardDevice.card_id.in_(card_ids)).delete(synchronize_session=False)
    # 删除卡密的用户绑定
    self.db.query(UserCard).filter(UserCard.card_id.in_(card_ids)).delete(synchronize_session=False)
    # 删除卡密
    self.db.query(Card).filter(Card.app_id == app_id).delete()

# 最后删除应用
self.db.delete(app)
self.db.commit()
```

**删除顺序**：
1. 删除 `user_tokens` 表中的记录
2. 删除 `card_devices` 表中的记录
3. 删除 `user_cards` 表中的记录
4. 删除 `cards` 表中的记录
5. 删除 `apps` 表中的记录

---

#### 3. 卡密删除修复 (`app/services/card_service.py`)

**修复前**：
```python
# 直接删除卡密，依赖数据库级联
self.db.delete(card)
self.db.commit()
```

**修复后**：
```python
# 先删除卡密的设备绑定（避免外键约束问题）
self.db.query(CardDevice).filter(CardDevice.card_id == card_id).delete()

# 删除卡密的用户绑定
self.db.query(UserCard).filter(UserCard.card_id == card_id).delete()

# 最后删除卡密
self.db.delete(card)
self.db.commit()
```

**删除顺序**：
1. 删除 `card_devices` 表中的记录
2. 删除 `user_cards` 表中的记录
3. 删除 `cards` 表中的记录

---

## 技术要点

### 1. 使用 Query.delete() 方法

```python
# 批量删除，效率更高
self.db.query(UserToken).filter(UserToken.user_id == user_id).delete()
```

优点：
- 直接在数据库层面执行 DELETE 语句
- 不需要先查询再删除
- 性能更好

### 2. synchronize_session 参数

```python
# 当使用 in_ 查询时，需要设置 synchronize_session=False
self.db.query(CardDevice).filter(CardDevice.card_id.in_(card_ids)).delete(synchronize_session=False)
```

说明：
- `synchronize_session=False`：不同步会话状态，提高性能
- 适用于批量删除操作
- 删除后立即 commit，不会有会话状态问题

### 3. 事务处理

```python
try:
    # 执行删除操作
    self.db.query(UserToken).filter(...).delete()
    self.db.delete(user)
    self.db.commit()
except Exception as e:
    self.db.rollback()  # 发生错误时回滚
    logger.error(f"删除失败: {str(e)}")
```

优点：
- 保证数据一致性
- 失败时自动回滚
- 不会留下脏数据

---

## 数据库设计建议

### 当前设计（不使用级联删除）

```python
user_id = Column(Integer, ForeignKey("users.id"), nullable=False)
```

优点：
- 数据安全性高
- 删除操作需要显式处理
- 避免误删除

缺点：
- 需要手动处理删除顺序
- 代码相对复杂

### 替代方案（使用级联删除）

```python
user_id = Column(Integer, ForeignKey("users.id", ondelete="CASCADE"), nullable=False)
```

优点：
- 数据库自动处理级联删除
- 代码简单

缺点：
- 可能导致意外的数据丢失
- 不够灵活

### 推荐做法

对于当前项目，建议保持现有设计（不使用数据库级联删除），原因：
1. 更好的控制力
2. 更清晰的删除逻辑
3. 更容易调试和维护
4. 可以在删除前进行额外的业务逻辑处理

---

## 测试验证

### 测试用户删除

```bash
# 运行测试脚本
python test_batch_delete_apis.py
```

### 手动测试步骤

1. **创建测试用户**
   ```bash
   POST /auth/register
   {
     "username": "test_user",
     "password": "test123456"
   }
   ```

2. **用户登录（生成 Token）**
   ```bash
   POST /auth/login
   {
     "username": "test_user",
     "password": "test123456",
     "app_key": "your_app_key",
     "device_id": "test_device"
   }
   ```

3. **删除用户**
   ```bash
   POST /auth/batch-delete-users
   [user_id]
   ```

4. **验证结果**
   - 检查 `users` 表：用户已删除
   - 检查 `user_tokens` 表：Token 已删除
   - 检查 `user_cards` 表：绑定已删除

---

## 性能优化

### 批量删除优化

对于大量数据的删除，可以考虑：

1. **分批删除**
   ```python
   batch_size = 100
   for i in range(0, len(card_ids), batch_size):
       batch = card_ids[i:i+batch_size]
       self.db.query(CardDevice).filter(CardDevice.card_id.in_(batch)).delete(synchronize_session=False)
       self.db.commit()
   ```

2. **使用原生 SQL**
   ```python
   self.db.execute(
       "DELETE FROM card_devices WHERE card_id IN :card_ids",
       {"card_ids": tuple(card_ids)}
   )
   ```

3. **异步处理**
   - 对于超大量数据，可以使用后台任务
   - 提供进度反馈
   - 避免请求超时

---

## 日志记录

修复后的代码保留了完整的日志记录：

```python
logger.info(f"成功删除用户: {user.username} (ID: {user_id})")
logger.warning(f"用户不存在，跳过删除: ID {user_id}")
logger.error(f"删除用户失败: ID {user_id}, 错误: {str(e)}")
```

日志级别：
- `INFO`：成功操作
- `WARNING`：跳过的操作（如用户不存在、管理员账户）
- `ERROR`：失败的操作

---

## 修复验证

### 验证清单

- ✅ 用户删除功能正常
- ✅ 应用删除功能正常
- ✅ 卡密删除功能正常
- ✅ 外键约束错误已解决
- ✅ 事务处理正确
- ✅ 日志记录完整
- ✅ 代码无语法错误

### 测试结果

所有批量删除功能已通过测试，不再出现外键约束错误。

---

## 总结

通过手动管理删除顺序，我们成功解决了外键约束问题。这种方法虽然代码稍微复杂一些，但提供了更好的控制力和可维护性。

关键点：
1. 先删除子记录，再删除父记录
2. 使用 Query.delete() 提高性能
3. 正确处理事务和异常
4. 保持完整的日志记录

---

## 修复时间

2026-02-02

## 修复者

Kiro AI Assistant
